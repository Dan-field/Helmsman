<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_boat</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>obj_dynamicParent</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>PLAYER_BOAT_ID = id;

// create hull fixture with properties
var fix_hull = physics_fixture_create();
physics_fixture_set_polygon_shape(fix_hull);
physics_fixture_add_point(fix_hull, 0, -144);
physics_fixture_add_point(fix_hull, 64, 0);
physics_fixture_add_point(fix_hull, 48, 112);
physics_fixture_add_point(fix_hull, -48, 112);
physics_fixture_add_point(fix_hull, -64, 0);
//physics_fixture_set_kinematic(fix_hull)
physics_fixture_set_angular_damping(fix_hull, 1);
physics_fixture_set_density(fix_hull, 0.6);
physics_fixture_set_friction(fix_hull, 0.3);
physics_fixture_set_linear_damping(fix_hull, 0.2);
physics_fixture_set_restitution(fix_hull, 0.1);

// create sail fixture with properties
var fix_sail = physics_fixture_create();
physics_fixture_set_polygon_shape(fix_sail);
physics_fixture_add_point(fix_sail, 0, 0);
physics_fixture_add_point(fix_sail, 5, 96);
physics_fixture_add_point(fix_sail, -5, 96);
physics_fixture_set_angular_damping(fix_sail, 0.9);
physics_fixture_set_density(fix_sail, 0.3);
physics_fixture_set_friction(fix_sail, 0.3);
physics_fixture_set_linear_damping(fix_sail, 0.6);
physics_fixture_set_restitution(fix_sail, 0.8);

// create rudder fixture with properties
var fix_rudder = physics_fixture_create();
physics_fixture_set_polygon_shape(fix_rudder);
physics_fixture_add_point(fix_rudder, -2, 0);
physics_fixture_add_point(fix_rudder, 2, 0);
physics_fixture_add_point(fix_rudder, 2, 36);
physics_fixture_add_point(fix_rudder, -2, 36);
//physics_fixture_set_kinematic(fix_rudder);
physics_fixture_set_angular_damping(fix_rudder, 10);
physics_fixture_set_density(fix_rudder, 0.5);
physics_fixture_set_friction(fix_rudder, 0.3);
physics_fixture_set_linear_damping(fix_rudder, 0.6);
physics_fixture_set_restitution(fix_rudder, 0.8);

// call an instance of a sail
var inst_sail = instance_create(id.x, id.y, obj_sail); 

// call an instance of a rudder
var inst_rudder = instance_create(id.x, id.y+112, obj_rudder);

// bind the fixtures to the boat and sail objects
physics_fixture_bind(fix_hull, id);
physics_fixture_bind(fix_sail, inst_sail);
physics_fixture_bind(fix_rudder, inst_rudder);

// join the boat and sail objects to each other with a revolute joint
physics_joint_revolute_create(id, inst_sail, id.x, id.y, -90, 90, 1, 0, 0, 0, 0); 

// join the boat and rudder objects to each other with a revolute joint
physics_joint_revolute_create(id, inst_rudder, id.x, id.y+112, -75, 75, 1, 1000, 0, 1, 0);

// join the sail to the hull using a rope joint
SHEET_LENGTH = 7;
main_sheet = physics_joint_rope_create(id, inst_sail, id.x, id.y+112, inst_sail.x, inst_sail.y+96, SHEET_LENGTH*10, 0);

// clean up
physics_fixture_delete(fix_hull);
physics_fixture_delete(fix_sail);
physics_fixture_delete(fix_rudder);

// set initial rotations
phy_rotation = 90;
obj_sail.phy_rotation = 50;
obj_rudder.phy_rotation = -90;

phy_linear_velocity_y = -10;

// set the boat's key variables

IS_SHOALED = false;
IS_SHOALED_old = false;
IS_BEACHED = false;
IS_BEACHED_old = false;
VELOCITY_STEP = 0;
BEACHING_VELOCITY = 0;
SHOALING_VELOCITY = 0;
// KEEL_COEFF = 60;
MAX_SIDEWAYS = 12; // max sideways speed, reflecting the effectiveness of the keel or centreboard
MAX_SHOALED = 30; // max forward speed when shoaled

SHEET_LENGTH_MAX = 14;
SHEET_LENGTH_MIN = 2;

HULL_LENGTH_FOR_BEACHING = 96;
BEAM_FOR_BEACHING = 48;
TRANSOM_FOR_BEACHING = 96;

PUSHING = false;

boat_sense = 1;
boat_sense_previous = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>PUSHING = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>physics_joint_set_value(main_sheet, phy_joint_max_length, SHEET_LENGTH);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>IS_BEACHED_old = IS_BEACHED;
IS_SHOALED_old = IS_SHOALED;

if (collision_point(id.x, id.y, obj_shoal, false, false))
{
    IS_SHOALED = true;
}
else IS_SHOALED = false;

var bow_point_off_x = HULL_LENGTH_FOR_BEACHING*sin(degtorad(phy_rotation));
var bow_point_off_y = HULL_LENGTH_FOR_BEACHING*cos(degtorad(phy_rotation));
var beam_point_off_x = BEAM_FOR_BEACHING*cos(degtorad(phy_rotation));
var beam_point_off_y = BEAM_FOR_BEACHING*sin(degtorad(phy_rotation));

if (collision_line(id.x + beam_point_off_x, id.y + beam_point_off_y, id.x - beam_point_off_x, id.y - beam_point_off_y, obj_sand_parent, true, false)
|| collision_line(id.x + bow_point_off_x, id.y - bow_point_off_y, id.x - bow_point_off_x, id.y + bow_point_off_y, obj_sand_parent, true, false))
{
    IS_BEACHED = true;
}
else
{
    IS_BEACHED = false;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// break the x &amp; y velocity vectors down into forward and sideways components
var fwd_component_of_x_vector = phy_linear_velocity_x*sin(degtorad(phy_rotation));
var fwd_component_of_y_vector = -phy_linear_velocity_y*cos(degtorad(phy_rotation));
var sideways_component_of_x_vector = phy_linear_velocity_x*cos(degtorad(phy_rotation));
var sideways_component_of_y_vector = phy_linear_velocity_y*sin(degtorad(phy_rotation));

// sum the parts for a total fwd component and sideways component
var fwd_velocity = fwd_component_of_x_vector + fwd_component_of_y_vector;
var sideways_velocity = sideways_component_of_x_vector + sideways_component_of_y_vector;

// Now that we have these vectors, we can manipulate them to adjust the forward and sideways speed of the boat

// limit the sideways component to MAX_SIDEWAYS if not shoaled or beached
// to simulate the function of the keel or centreboard.
// Or limit the sideways component to shoal_factor*MAX_SIDEWAYS if shoaled, or zero if beached

if (IS_BEACHED)
{
    sideways_velocity = 0;
}
else if (IS_SHOALED)
{
    var shoal_factor = 0.2;
    if (sideways_velocity &gt; shoal_factor*MAX_SIDEWAYS)
    {
        sideways_velocity = shoal_factor*MAX_SIDEWAYS;
    }
    else if (sideways_velocity &lt; -shoal_factor*MAX_SIDEWAYS)
    {
        sideways_velocity = -shoal_factor*MAX_SIDEWAYS;
    }
}
else
{
    if (sideways_velocity &gt; MAX_SIDEWAYS)
    {
        sideways_velocity = MAX_SIDEWAYS;
    }
    else if (sideways_velocity &lt; -MAX_SIDEWAYS)
    {
        sideways_velocity = -MAX_SIDEWAYS;
    }
}

// The following section is designed to achieve a smooth deceleration in the event of beaching or shoaling
if (IS_BEACHED &amp;&amp; not(IS_BEACHED_old)) // this is the first step of a new beaching
{
    VELOCITY_STEP = 0.06*fwd_velocity;
    BEACHING_VELOCITY = fwd_velocity - VELOCITY_STEP;
}
else if (IS_SHOALED &amp;&amp; not(IS_SHOALED_old)) // this is the first step of a new shoaling
{
    VELOCITY_STEP = 0.05*(fwd_velocity-MAX_SHOALED);
    SHOALING_VELOCITY = fwd_velocity - VELOCITY_STEP;
}

// limit the movement IF the boat is beached or shoaled
// note, this has been updated to work in reverse as well as forwards
if (IS_BEACHED &amp;&amp; not(PUSHING))
{
    if (abs(BEACHING_VELOCITY) &lt; abs(VELOCITY_STEP)) BEACHING_VELOCITY = 0; // if the desired velocity is smaller than one velocity step, just make it zero
    fwd_velocity = BEACHING_VELOCITY; // limit the forward velocity to the desired velocity
    if (abs(BEACHING_VELOCITY) &gt;= abs(VELOCITY_STEP)) BEACHING_VELOCITY -= VELOCITY_STEP; // if the desired velocity is greater than a step, decrement it
}
else if (IS_BEACHED &amp;&amp; PUSHING)
{
    if (fwd_velocity &gt; MAX_SHOALED) fwd_velocity = MAX_SHOALED;
    if (fwd_velocity &lt; -MAX_SHOALED) fwd_velocity = -MAX_SHOALED;
}
else if (IS_SHOALED)
{
    if (fwd_velocity &gt; 0) fwd_velocity = SHOALING_VELOCITY;
    if (fwd_velocity &lt; -MAX_SHOALED) fwd_velocity = -MAX_SHOALED;
    if (SHOALING_VELOCITY &gt; MAX_SHOALED) SHOALING_VELOCITY -= VELOCITY_STEP;
    else SHOALING_VELOCITY = MAX_SHOALED;
}

// now convert the adjusted velocity vectors back into the physics velocity in the room
// break the fwd and (limited) side vectors into their contribution to x &amp; y velocities
var x_component_of_fwd_vector = fwd_velocity*sin(degtorad(phy_rotation));
var y_component_of_fwd_vector = -fwd_velocity*cos(degtorad(phy_rotation));
var x_component_of_sideways_vector = sideways_velocity*cos(degtorad(phy_rotation));
var y_component_of_sideways_vector = sideways_velocity*sin(degtorad(phy_rotation));

// re-set the x and y velocities using the x sum and y sum
phy_linear_velocity_x = x_component_of_fwd_vector + x_component_of_sideways_vector;
phy_linear_velocity_y = y_component_of_fwd_vector + y_component_of_sideways_vector;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="87">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (IS_BEACHED)
{
    PUSHING = true;
    alarm_set(11, 2); //set the "pushing" alarm to exit pushing mode
    IS_BEACHED_old = false;
    physics_apply_local_impulse(0, 0, 0, -500);
    // forwards push
}
else
{
    SHEET_LENGTH += 0.2;
    if (SHEET_LENGTH &gt; SHEET_LENGTH_MAX) SHEET_LENGTH = SHEET_LENGTH_MAX;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="83">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (IS_BEACHED)
{
    PUSHING = true;
    alarm_set(11, 2); //set the "pushing" alarm to exit pushing mode
    IS_BEACHED_old = false;
    physics_apply_local_impulse(0, 0, 0, 500);
    // backwards push
}
else
{
    SHEET_LENGTH -= 0.2;
    if (SHEET_LENGTH &lt; SHEET_LENGTH_MIN) SHEET_LENGTH = SHEET_LENGTH_MIN;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="40">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (IS_BEACHED)
{
    PUSHING = true;
    alarm_set(11, 2); //set the "pushing" alarm to exit pushing mode
    IS_BEACHED_old = false;
    physics_apply_local_impulse(0, 0, 0, 500);
    // backwards push
}
else
{
    SHEET_LENGTH -= 0.2;
    if (SHEET_LENGTH &lt; SHEET_LENGTH_MIN) SHEET_LENGTH = SHEET_LENGTH_MIN;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="38">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (IS_BEACHED)
{
    PUSHING = true;
    alarm_set(11, 2); //set the "pushing" alarm to exit pushing mode
    IS_BEACHED_old = false;
    physics_apply_local_impulse(0, 0, 0, -500);
    // forwards push
}
else
{
    SHEET_LENGTH += 0.2;
    if (SHEET_LENGTH &gt; SHEET_LENGTH_MAX) SHEET_LENGTH = SHEET_LENGTH_MAX;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="76">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// break wind down into x and y components
wind_x_component = -sin(degtorad(WIND_DIR))*WIND_SPEED;
wind_y_component = cos(degtorad(WIND_DIR))*WIND_SPEED;

// set up variables
var angle_to_wind = angle_difference(phy_rotation, WIND_DIR);

// is the wind from the left or the right?
if (angle_to_wind &gt; 0 &amp;&amp; angle_to_wind &lt; 180) boat_sense = 1;
else if (angle_to_wind &gt; -180 &amp;&amp; angle_to_wind &lt; 0) boat_sense = -1;
else boat_sense = boat_sense_previous; // angle is exactly zero or 180
boat_sense_previous = boat_sense; // ready for the next time-step

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw_text(50, 0, "#Is Beached: " + string(IS_BEACHED));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (boat_sense = 1 &amp;&amp; boat_sense_previous = 1)
{
    draw_sprite_ext(spr_boat, 0, id.x, id.y, 1, 1, -id.phy_rotation, c_white, 1);
}
else
{
    draw_sprite_ext(spr_boat, 1, id.x, id.y, 1, 1, -id.phy_rotation, c_white, 1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
